<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Tau render</title>
    <!--- link to the last version of babylon - -->

    <script src="./babylon.custom.withglTF.js"></script>
    <!-- <script src="./babylon.glTF2FileLoader.js"></script> -->
    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }

        #customBabylonLoadingScreen {
            pointer-events: none;
            font-size: 40px;
            position: absolute;
            top: 0;
            left: 0;
        }
        #BabylonFinishedIndicator {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        window.addEventListener('DOMContentLoaded', function() {
            // get the canvas DOM element
            var canvas = document.getElementById('renderCanvas');

            let pixelRatioLimit = 2;
            if (window.location.hash.indexOf('pixelRatioLimit1') !== -1) {
                // Usage: https://blah.com/render.html/#anythingpixelRatioLimit1anythingelse
                pixelRatioLimit = 1;
                window.a = true
            }

            // load the 3D engine
            var engine = new BABYLON.Engine(canvas, true, {
              limitDeviceRatio: pixelRatioLimit,
            }, true); // canvas, antialias, opts, adaptToDeviceRatio
            // engine.setHardwareScalingLevel(0.5); // Uncomment for MEGA resolution on devices with pixel ratio 1

            let forceRerender = true;

            engine.loadingScreen = {
                // Custom loading screen usage: https://github.com/BabylonJS/Babylon.js/blob/master/src/Loading/babylon.loadingScreen.ts#L21
                displayLoadingUI: () => {
                    this._loadingDiv = document.createElement('div');
                    this._loadingDiv.id = 'customBabylonLoadingScreen';
                    this._loadingTextDiv = document.createElement('div');
                    this._loadingTextDiv.innerHTML = 'Custom loading screen';
                    this._loadingDiv.appendChild(this._loadingTextDiv);
                    document.body.appendChild(this._loadingDiv);
                },
                hideLoadingUI: () => {
                    document.body.removeChild(this._loadingDiv);
                    this._finishedIndicator = document.createElement('div');
                    this._finishedIndicator.id = 'BabylonFinishedIndicator';
                    document.body.appendChild(this._finishedIndicator);
                }
            };

var createScene = function() {
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(1, 1, 1);
    scene.clearColor = new BABYLON.Color3(0.96875, 0.96875, 0.96875); // Uncomment for gray
    scene.ambientColor = new BABYLON.Color3(0.5,1,1);
    // scene.debugLayer.show();

    // Background under CC0 license: https://wallpaper.wiki/aluminum-background-download-free.html/wallpaper-wiki-full-hd-aluminum-image-pic-wpc0013331
    var background = new BABYLON.Layer("back", "/assets/background.jpg", scene);
    background.isBackground = true;

    var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 0, BABYLON.Vector3.Zero(), scene);
    window.camera = camera; // For debugging
    camera.inertia = 0.875;
    camera.setPosition(new BABYLON.Vector3(0, 0.5, 3));
    camera.attachControl(canvas, false);
    camera.fov = 0.4; // FOV prevents clipping issues
    camera.lowerBetaLimit = 0.3; // Limit on camera rotation at the top
    camera.upperBetaLimit = 2.84; // Limit on camera rotation at the bottom. max is PI. So 3.14 - 0.3 = 2.84
    // TODO: react to the canvas size
    camera.radius = 6;
    camera.lowerRadiusLimit = 4; // Limit zooming to be zoomed in to 4
    camera.upperRadiusLimit = 10; // Limit zooming out to 10
    camera.attachControl(canvas, true);

    var fxaaAntialiasing = new BABYLON.FxaaPostProcess("fxaa", 2.0, camera);
    // var fsaaAntialiasing = new BABYLON.PassPostProcess("fsaa", 2.0, camera); // FSAA doesn't really help


    // Cube texture from:  http://www.humus.name/index.php?page=Textures&start=96
    // This cube texture is the work of Emil Persson, aka Humus.
    // Licensed under a Creative Commons Attribution 3.0 Unported License.
    // BABYLON.CubeTexture constructor will add suffixes to the file to be:
    //          "/assets/meadow_px.jpg",
    //          "/assets/meadow_py.jpg",
    //          "/assets/meadow_pz.jpg",
    //          "/assets/meadow_nx.jpg",
    //          "/assets/meadow_ny.jpg",
    //          "/assets/meadow_nz.jpg",
    var meadowCubeTexture = new BABYLON.CubeTexture("/assets/meadow256", scene);

    // SIDE EFFECT: This PBR material is kinda weird because it affects the scene even if we dont use it
    var pbr = new BABYLON.PBRMaterial("pbr", scene);
    pbr.reflectionTexture = meadowCubeTexture;
    pbr.cameraContrast = 1; // Default camera contrast is 1
    pbr.cameraExposure = 2; // Default camera exposure is 1

    // var sphere = BABYLON.Mesh.CreateSphere('sphere1', 60, 1, scene);
    // sphere.position.y = -1.3;
    // sphere.material = pbr;

    // Hemispheric light is like sunlight. Rays are parallel
    // Vector is x,y,z. For directly above us, just do 0,5,0
    // Positive y is above us.
    // Positive z is behind us. Negative z is in front of us.
    // Positive x is to the left of us.
    var sun = new BABYLON.HemisphericLight('sun', new BABYLON.Vector3(5,5,5), scene);
    sun.intensity = 0.5;

    var groundLight = new BABYLON.HemisphericLight('groundLight', new BABYLON.Vector3(0,-5,0), scene);
    groundLight.intensity = 0.125;

    // This point light is like the sun except it's wider and softer
    var softSun = new BABYLON.PointLight("softSun", new BABYLON.Vector3(80,80,80), scene);
    softSun.intensity = 4000;
    softSun.radius = 30;

    var helmetmeshes;
    var bottleMeshes;
    var loader = new BABYLON.AssetsManager(scene);
    var item = loader.addMeshTask("item", "", "/assets/", "DamagedHelmet.gltf");
    item.onSuccess = function(task) {
        helmetmeshes = task.loadedMeshes;

        // Some 3d editors have negative scaling ... so we have to un-negative it
        // helmetmeshes[1].scaling.y = -5;
        // helmetmeshes[1].scaling.x = -5;
        // helmetmeshes[1].scaling.z = 5;
        helmetmeshes[1].rotation.z = 3.141;
        helmetmeshes[1].position.x = 0;
        helmetmeshes[1].material.reflectionTexture = meadowCubeTexture;
        forceRerender = true;
    }

    loader.addMeshTask("item2", "", "/assets/", "WaterBottle.gltf").onSuccess = function(task) {
        bottleMeshes = task.loadedMeshes;

        // Some 3d editors have negative scaling ... so we have to un-negative it
        bottleMeshes[1].scaling.y = -5;
        bottleMeshes[1].scaling.x = -5;
        bottleMeshes[1].scaling.z = 5;
        bottleMeshes[1].rotation.z = 3.141;
        bottleMeshes[1].position.x = -1.2;
        bottleMeshes[1].material.reflectionTexture = meadowCubeTexture;
        forceRerender = true;
    }

    loader.load();

    scene.registerBeforeRender(function () {
        if (bottleMeshes) {
            bottleMeshes[1].rotation.y += 0.05;
        }
    });

    // return the created scene
    return scene;
            }

            // call the createScene function
            var scene = createScene();

            let frameCooldown = 0;

            let cam = scene.activeCamera;
            // Will only re-render if the camera moved
            var smartRender = function() {
                if (frameCooldown > 0) {
                    frameCooldown -= 1;
                    scene.render();
                } else if (forceRerender ||
                    Math.abs(cam.inertialRadiusOffset) > 0 ||
                    Math.abs(cam.inertialAlphaOffset) > 0 ||
                    Math.abs(cam.inertialBetaOffset) > 0) {
                    forceRerender = false;
                    frameCooldown = 2;
                    scene.render();
                }
            }
            // engine.stopRenderLoop();
            engine.runRenderLoop(smartRender);

            // the canvas/window resize event handler
            window.addEventListener('resize', function(){
                forceRerender = true;
                engine.resize();
            });
        });
    </script>
</body>
</html>
